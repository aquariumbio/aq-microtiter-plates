{"config":{"title":"Aquarium Microtiter Plates","description":"Models for working with microtiter plates","copyright":"University of Washington","version":"0.0.1","authors":[{"name":"Devin Strickland","affiliation":"University of Washington"},{"name":"Cannon Mallory","affilation":"","affiliation":"University of Washington"}],"maintainer":{"name":"Devin Strickland","email":"strcklnd@uw.edu"},"acknowledgements":[{"name":"Benjamin Keller","affilation":"","affiliation":"University of Washington"}],"github":{"user":"dvnstrcklnd","repo":"microtiter-plates","organization":"aquariumbio"},"keywords":null,"aquadoc_version":"1.0.2","aquarium_version":"\u003c%= Bioturk::Application.config.aquarium_version %\u003e"},"components":[{"library":{"name":"MicrotiterPlates","category":"Microtiter Plates","code_source":"# typed: false\n# frozen_string_literal: true\n\nneeds 'Standard Libs/AssociationManagement'\nneeds 'Microtiter Plates/PlateLayoutGenerator'\n\nmodule MicrotiterPlates\n  # Convert a letter to the corresponding array index\n  #\n  # @param letter [String] the letter (usually of a row)\n  # @return Fixnum\n  def letter_to_index(letter)\n    alphabet_array.index(letter.upcase)\n  end\n\n  # Convert an array index to the corresponding letter of the alphabet\n  #\n  # @param index [Fixnum] the index (usually of a row)\n  # @return String\n  def index_to_letter(index)\n    alphabet_array[index]\n  end\n\n  # Array of all letters of the alphablet in uppercase\n  #\n  # @return Array\u003cString\u003e\n  def alphabet_array\n    ('A'..'Z').to_a\n  end\n\n  # Get the alpha component of an alphanumumeric coordinate\n  #\n  # @param alphanum [String]\n  # @return [String, nil] the first contiguous run of letters or nil if no\n  #   letters are found\n  def alpha_component(alphanum)\n    mtch = alphanum.match(/[[:alpha:]]+/)\n    return mtch[0] if mtch\n  end\n\n  # Get the numeric component of an alphanumumeric coordinate\n  #\n  # @param alphanum [String]\n  # @return [Fixnum, nil] the first contiguous run of digits or nil if no\n  #   digits are found\n  def numeric_component(alphanum)\n    mtch = alphanum.match(/\\d+/)\n    return mtch[0].to_i if mtch\n  end\nend\n\n# Factory class for building `MicrotiterPlate`s\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\n#\nclass MicrotiterPlateFactory\n  # Builds a new `MicrotiterPlate`\n  #\n  # @param collection [Collection] the `Collection` that is to be managed\n  # @param group_size [Fixnum] the size of groups of wells, e.g., corresponding\n  #   to replicates (see `PlateLayoutGenerator`)\n  # @param method [String] the method for creating a new `PlateLayoutGenerator`\n  # @return [MicrotiterPlate]\n  def self.build(collection:, group_size:, method:)\n    MicrotiterPlate.new(\n      collection: collection,\n      group_size: group_size,\n      method: method\n    )\n  end\nend\n\n# Class for modeling the addition of samples to a microtiter (e.g, 96-well)\n#   plate\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\n#\nclass MicrotiterPlate\n  include AssociationManagement\n  include PartProvenance\n\n  attr_reader :collection\n\n  # Instantiates `MicrotiterPlate`\n  #\n  # @param collection [Collection] the `Collection` that is to be managed\n  # @param group_size [Fixnum] the size of groups of wells, e.g., correspionding\n  #   to replicates (see `PlateLayoutGenerator`)\n  # @param method [String] the method for creating a new `PlateLayoutGenerator`\n  # @return [MicrotiterPlate]\n  def initialize(collection:, group_size:, method:)\n    @collection = collection\n    @plate_layout_generator = PlateLayoutGeneratorFactory.build(\n      group_size: group_size,\n      method: method\n    )\n  end\n\n  # Associates the provided data to the next `PlateLayoutGenerator` index\n  #   that does not point to a `Part` that already has a `DataAssociation`\n  #   for `key` and returns the index\n  #\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param data [serializable object]  the data for the association\n  # @param column [Fixnum] an alternative column index to start with\n  # @return [Array\u003cFixnum\u003e]\n  def associate_next_empty(key:, data:, column: nil)\n    nxt = next_empty(key: key, column: column)\n    associate(index: nxt, key: key, data: data)\n    nxt\n  end\n\n  # Associates the provided data to the next `PlateLayoutGenerator` group\n  #   that does not point to any `Part` that already has a `DataAssociation`\n  #   for `key` and returns the group\n  #\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param data [serializable object]  the data for the association\n  # @param column [Fixnum] an alternative column index to start with\n  # @return [Array\u003cArray\u003cFixnum\u003e\u003e]\n  def associate_next_empty_group(key:, data:, column: nil)\n    nxt_grp = next_empty_group(key: key, column: column)\n    associate_group(group: nxt_grp, key: key, data: data)\n    nxt_grp\n  end\n\n  # Uses `PartProvenance` to associate the the provided provenance data to\n  #   the next `PlateLayoutGenerator` index that does not point to a `Part`\n  #   that already has a `DataAssociation` for `key` and returns the index\n  #\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param data [Array\u003cHash\u003e] the data for the association; each Hash must\n  #   include an `item: Item` pair\n  # @param column [Fixnum] an alternative column index to start with\n  # @return [Array\u003cFixnum\u003e]\n  def associate_provenance_next_empty(key:, data:, column: nil)\n    nxt = next_empty(key: key, column: column)\n    associate_provenance(index: nxt, key: key, data: data)\n    nxt\n  end\n\n  # Uses `PartProvenance` to associate the the provided provenance data to\n  #   the next `PlateLayoutGenerator` group that does not point to any `Part`\n  #    that already has a `DataAssociation` for `key` and returns the group\n  #\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param data [Array\u003cHash\u003e] the data for the association; each Hash must\n  #   include an `item: Item` pair\n  # @param column [Fixnum] an alternative column index to start with\n  # @return [Array\u003cArray\u003cFixnum\u003e\u003e]\n  def associate_provenance_next_empty_group(key:, data:, column: nil)\n    nxt_grp = next_empty_group(key: key, column: column)\n    associate_provenance_group(group: nxt_grp, key: key, data: data)\n    nxt_grp\n  end\n\n  # Returns the next `PlateLayoutGenerator` index that does not point to a\n  #   `Part` that already has a `DataAssociation` for `key`\n  #\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param column [Fixnum] an alternative column index to start with\n  # @return [Array\u003cFixnum\u003e]\n  def next_empty(key:, column: nil)\n    nxt = nil\n    loop do\n      nxt = @plate_layout_generator.next(column: column)\n      prt = @collection.part(nxt[0], nxt[1])\n      break unless prt.associations[key].present?\n    end\n    nxt\n  end\n\n  # Returns the next `PlateLayoutGenerator` group that does not point to any\n  #   `Part` that already has a `DataAssociation` for `key`\n  #\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param column [Fixnum] an alternative column index to start with\n  # @return [Array\u003cArray\u003cFixnum\u003e\u003e]\n  def next_empty_group(key:, column: nil)\n    nxt_grp = nil\n    loop do\n      present = false\n      nxt_grp = @plate_layout_generator.next_group(column: column)\n      nxt_grp.each do |nxt|\n        prt = @collection.part(nxt[0], nxt[1])\n        present = true if prt.associations[key].present?\n      end\n      break unless present\n    end\n    nxt_grp\n  end\n\n  # Associates the provided data to indices of the provided group\n  #\n  # @param group [Array\u003cArray\u003cFixnum\u003e\u003e]\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param data [serializable object]  the data for the association\n  # @return [void]\n  def associate_group(group:, key:, data:)\n    group.each { |i| associate(index: i, key: key, data: data) }\n  end\n\n  # Uses `PartProvenance` to associate the provided provenance data to\n  #   indices of the provided group\n  #\n  # @param group [Array\u003cArray\u003cFixnum\u003e\u003e]\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param data [Array\u003cHash\u003e] the data for the association; each Hash must\n  #   include an `item: Item` pair\n  # @return [void]\n  def associate_provenance_group(group:, key:, data:)\n    group.each { |i| associate_provenance(index: i, key: key, data: data) }\n  end\n\n  # Make a simple data association on a part\n  #\n  # @param index [Array\u003cFixnum\u003e] the row, column pair pointing to the part\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param data [serializable object]  the data for the association\n  # @return [void]\n  def associate(index:, key:, data:)\n    part = @collection.part(index[0], index[1])\n    part.associate(key, data)\n  end\n\n  # Uses `PartProvenance` to associate the provided provenance data to\n  #   a part\n  #\n  # @param index [Array\u003cFixnum\u003e] the row, column pair pointing to the part\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param data [serializable object] the data for the association; Hash must\n  #   include an `item: Item` pair\n  # @return [void]\n  def associate_provenance(index:, key:, data:)\n    to_item = @collection.part(index[0], index[1])\n    data.each do |datum|\n      # Make sure you aren't modifying a shared data structure\n      datum = datum.dup\n      from_item = datum.delete(:item)\n      next unless from_item\n\n      add_one_to_one_provenance(\n        from_item: from_item,\n        to_item: to_item,\n        additional_relation_data: datum\n      )\n    end\n    associate(index: index, key: key, data: 'added')\n  end\n\n  private\n\n  # Add provenance data to a source-destination pair of items\n  #\n  # @param from_item [Item]\n  # @param to_item [Item]\n  # @param additional_relation_data [serializable object] additional data that\n  #   will be added to the provenace association\n  # @return [void]\n  def add_one_to_one_provenance(from_item:, to_item:,\n                                additional_relation_data: nil)\n    from_map = AssociationMap.new(from_item)\n    to_map = AssociationMap.new(to_item)\n\n    add_provenance(\n      from: from_item, from_map: from_map,\n      to: to_item, to_map: to_map,\n      additional_relation_data: additional_relation_data\n    )\n    from_map.save\n    to_map.save\n  end\nend\n"}},{"library":{"name":"PlateLayoutGenerator","category":"Microtiter Plates","code_source":"# frozen_string_literal: true\n\n# Factory class for instantiating `PlateLayoutGenerator`\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass PlateLayoutGeneratorFactory\n  # Instantiates `PlateLayoutGenerator`\n  #\n  # @param group_size [FixNum] the size of groups of wells, e.g., corresponding\n  #   to replicates\n  # @return [PlateLayoutGenerator]\n  def self.build(group_size: 1, method: nil, dimensions: [8, 12])\n    PlateLayoutGenerator.new(group_size: group_size,\n                             method: method,\n                             dimensions: dimensions)\n  end\nend\n\n# Provides individual indices or batches of indices from a microtiter plate, in\n#   order from top left ,and yielding each index only once\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass PlateLayoutGenerator\n  def initialize(group_size: 1, method: nil, dimensions: [8, 12])\n    @group_size = group_size\n    method ||= :cdc_sample_layout\n    @layout = send(method)\n    @rows = dimensions[0]\n    @columns = dimensions[1]\n    @ii = []\n    @column = []\n    @first_index = []\n  end\n\n  def next(column: nil)\n    i = column ? first_index_in(column) : 0\n    @layout.slice!(i)\n  end\n\n  def next_group(column: nil)\n    i = column ? first_index_in(column) : 0\n    @layout.slice!(i, @group_size)\n  end\n\n  def iterate_column(column)\n    return nil if column.blank?\n    if column \u003c @columns\n      column += 1\n    else\n      column = 0\n    end\n    column\n  end\n\n  private\n\n  def first_index_in(column)\n    @layout.index { |x| x[1] == column }\n  end\n\n  def cdc_sample_layout\n    lyt = []\n    [0, 4].each do |j|\n      cols = Array.new(12) { |c| c }\n      cols.each { |c| @group_size.times { |i| lyt \u003c\u003c [i + j, c] } }\n    end\n    lyt\n  end\n\n  # @todo make this responsive to @group_size\n  def cdc_primer_layout\n    lyt = []\n    3.times { |i| [0, 4].each { |j| 12.times { |k| lyt \u003c\u003c [i + j, k] } } }\n    lyt\n  end\n\n  #==================Modified CDC Methods ====================#\n\n  def modified_sample_layout_two\n    lyt = []\n    make_modified_start_array(2).each do |j|\n      cols = Array.new(@columns) { |c| c }\n      cols.each { |c| 2.times { |i| lyt \u003c\u003c [i+j, c] } }\n    end\n    lyt\n  end\n\n  def modified_sample_layout_one\n    lyt = []\n    make_modified_start_array(1).each do |j|\n      cols = Array.new(@columns) { |c| c }\n      cols.each { |c| 1.times { |i| lyt \u003c\u003c [i + j, c] } }\n    end\n    lyt\n  end\n\n  def modified_primer_layout\n    lyt = []\n    1.times do |i|\n      make_modified_start_array(1).each do |j|\n        @columns.times { |k| lyt \u003c\u003c [i + j, k] }\n      end\n    end\n    lyt\n  end\n\n  #============= Helper Methods =========#\n\n  # This allows the modified CDC protocol to be run on flexible plate sizes\n  # It may be needed in cases when 96 well plates are turned sideways or if\n  # run at lower/higher throughput\n  #\n  # @param size [Int] usually is the same as group size. I wanted to hard code\n  #   this in... still debating if thats the right call... easy to change tho\n  def make_modified_start_array(size)\n    rem = @rows % size\n    size += 1 unless rem.zero?\n    start_array = []\n    @rows.times do |idx|\n      start_row = size * idx\n      break if start_row == @rows \u0026\u0026 size != 1\n\n      start_array.push(start_row)\n    end\n    start_array\n  end\n\nend\n"}},{"sample_types":[{"id":10,"name":"Master Mix","description":"Master Mix sample type TODO Make better description","created_at":"2020-06-29T10:15:28.000-07:00","updated_at":"2020-06-29T10:15:28.000-07:00","field_types":[]},{"id":3,"name":"qPCR Reaction","description":"qPCR Reaction","created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:01:19.000-07:00","field_types":[]}],"object_types":[{"id":18,"name":"96-well qPCR Plate","description":"96-well qPCR Reaction","min":0,"max":1,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:02:42.000-07:00","updated_at":"2020-06-29T10:26:41.000-07:00","unit":"qPCR Reaction","cost":0.01,"release_method":"return","release_description":"","sample_type_id":3,"image":"","prefix":"","rows":8,"columns":12,"sample_type_name":"qPCR Reaction"}],"operation_type":{"name":"Microtiter Plate Test","category":"Test","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"PCR Plate","sample_types":["Master Mix"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"PCR Plate","sample_types":["qPCR Reaction"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# typed: false\n# frozen_string_literal: true\n\nneeds 'Microtiter Plates/MicrotiterPlates'\nneeds 'Collection Management/CollectionDisplay'\nneeds 'Standard Libs/AssociationManagement'\nneeds 'Standard Libs/debug'\n\nclass Protocol\n  include CollectionDisplay\n  include AssociationManagement\n  include Debug\n\n  VERBOSE = false\n\n  KEY = 'patient_sample'\n  GROUP_SIZE = 3\n  METHOD = :cdc_sample_layout\n\n  def main\n    op = operations.first\n    collection = op.input('PCR Plate').collection\n    setup_test_plate(collection: collection)\n\n    microtiter_plate = MicrotiterPlateFactory.build(\n      collection: collection,\n      group_size: GROUP_SIZE,\n      method: METHOD\n    )\n\n    # Should skip the first column becasue it has `patient_sample` filled:\n    # [[0, 1], [1, 1], [2, 1]]\n    # NOT\n    # [[0, 0], [1, 0], [2, 0]]\n    #\n    inspect microtiter_plate.next_empty_group(key: KEY).to_s\n\n    {}\n\n  end\n\n  # Populate test plate with qPCR Reactions and one no template control (NTC)\n  #\n  def setup_test_plate(collection:)\n    qpcr_reaction = Sample.find_by_name('Test qPCR Reaction')\n    ntc_item = Item.find(258)\n\n    layout_generator = PlateLayoutGeneratorFactory.build(\n      group_size: GROUP_SIZE,\n      method: METHOD\n    )\n\n    i = 0\n    loop do\n      layout_group = layout_generator.next_group\n      break unless layout_group.present?\n\n      layout_group.each do |r, c|\n        collection.set(r, c, qpcr_reaction)\n        next if i.positive?\n\n        part = collection.part(r, c)\n        inspect part, \"part at #{[r, c]}\" if VERBOSE\n        part.associate(KEY, ntc_item)\n        inspect part.associations, \"#{KEY} at #{[r, c]}\" if VERBOSE\n      end\n      i += 1\n    end\n\n    show_result(collection: collection) if VERBOSE\n    inspect collection.parts.to_s if VERBOSE\n  end\n\n  def show_result(collection:)\n    show do\n      table highlight_non_empty(collection)\n    end\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"# frozen_string_literal: true\n\nclass ProtocolTest \u003c ProtocolTestBase\n  def setup\n    add_random_operations(1)\n  end\n\n  def analyze\n    log('Hello from Nemo')\n    assert_equal(@backtrace.last[:operation], 'complete')\n  end\nend\n","timing":null}}]}