{"config":{"title":"microtiter_plates","description":"No description given","copyright":"No copyright declared","version":"no version info","authors":[],"maintainer":{"name":"No maintainer","email":"noone@nowehere"},"acknowledgements":[],"github":{"repo":"none","user":"none","access_token":"none"},"keywords":[],"aquadoc_version":"1.0.2"},"components":[{"library":{"name":"MicrotiterPlate","category":"Microtiter Plates","code_source":"# typed: false\n# frozen_string_literal: true\n\nneeds 'Microtiter Plates/PlateLayoutGenerator'\n\nmodule MicrotiterPlates\n  # Convert a letter to the corresponding array index\n  #\n  # @param letter [String] the letter (usually of a row)\n  # @return Fixnum\n  def letter_to_index(letter)\n    alphabet_array.index(letter.upcase)\n  end\n\n  # Convert an array index to the corresponding letter of the alphabet\n  #\n  # @param index [Fixnum] the index (usually of a row)\n  # @return String\n  def index_to_letter(index)\n    alphabet_array[index]\n  end\n\n  # Array of all letters of the alphablet in uppercase\n  #\n  # @return Array\u003cString\u003e\n  def alphabet_array\n    ('A'..'Z').to_a\n  end\n\n  # Get the alpha component of an alphanumumeric coordinate\n  #\n  # @param alphanum [String]\n  # @return [String, nil] the first contiguous run of letters or nil if no\n  #   letters are found\n  def alpha_component(alphanum)\n    mtch = alphanum.match(/[[:alpha:]]+/)\n    return mtch[0] if mtch\n  end\n\n  # Get the numeric component of an alphanumumeric coordinate\n  #\n  # @param alphanum [String]\n  # @return [Fixnum, nil] the first contiguous run of digits or nil if no\n  #   digits are found\n  def numeric_component(alphanum)\n    mtch = alphanum.match(/\\d+/)\n    return mtch[0].to_i if mtch\n  end\nend\n\n# Factory class for building `MicrotiterPlate`s\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\n#\nclass MicrotiterPlateFactory\n  # Builds a new `MicrotiterPlate`\n  #\n  # @param collection [Collection] the `Collection` that is to be managed\n  # @param group_size [Fixnum] the size of groups of wells, e.g., corresponding\n  #   to replicates (see `PlateLayoutGenerator`)\n  # @param method [String] the method for creating a new `PlateLayoutGenerator`\n  # @return [MicrotiterPlate]\n  def self.build(collection:, group_size:, method:)\n    MicrotiterPlate.new(\n      collection: collection,\n      group_size: group_size,\n      method: method\n    )\n  end\nend\n\n# Class for modeling the addition of samples to a microtiter (e.g, 96-well)\n#   plate\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\n#\nclass MicrotiterPlate\n  attr_reader :collection\n\n  # Instantiates `MicrotiterPlate`\n  #\n  # @param collection [Collection] the `Collection` that is to be managed\n  # @param group_size [Fixnum] the size of groups of wells, e.g., correspionding\n  #   to replicates (see `PlateLayoutGenerator`)\n  # @param method [String] the method for creating a new `PlateLayoutGenerator`\n  # @return [MicrotiterPlate]\n  def initialize(collection:, group_size:, method:)\n    @collection = collection\n    @plate_layout_generator = PlateLayoutGeneratorFactory.build(\n      group_size: group_size,\n      method: method\n    )\n  end\n\n  # Associates the provided data to the next `PlateLayoutGenerator` index\n  #   that does not point to a `Part` that already has a `DataAssociation`\n  #   for `key` and returns the index\n  #\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param data [serializable object]  the data for the association\n  # @param column [Fixnum] an alternative column index to start with\n  # @return [Array\u003cFixnum\u003e]\n  def associate_next_empty(key:, data:, column: nil)\n    nxt = next_empty(key: key, column: column)\n    associate(index: nxt, key: key, data: data)\n    nxt\n  end\n\n  # Associates the provided data to the next `PlateLayoutGenerator` group\n  #   that does not point to any `Part` that already has a `DataAssociation`\n  #   for `key` and returns the group\n  #\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param data [serializable object]  the data for the association\n  # @param column [Fixnum] an alternative column index to start with\n  # @return [Array\u003cArray\u003cFixnum\u003e\u003e]\n  def associate_next_empty_group(key:, data:, column: nil)\n    nxt_grp = next_empty_group(key: key, column: column)\n    nxt_grp.each { |nxt| associate(index: nxt, key: key, data: data) }\n    nxt_grp\n  end\n\n  # Returns the next `PlateLayoutGenerator` index that does not point to a\n  #   `Part` that already has a `DataAssociation` for `key`\n  #\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param column [Fixnum] an alternative column index to start with\n  # @return [Array\u003cFixnum\u003e]\n  def next_empty(key:, column: nil)\n    nxt = nil\n    loop do\n      nxt = @plate_layout_generator.next(column: column)\n      prt = @collection.part(nxt[0], nxt[1])\n      break unless prt.associations[key].present?\n    end\n    nxt\n  end\n\n  # Returns the next `PlateLayoutGenerator` group that does not point to any\n  #   `Part` that already has a `DataAssociation` for `key`\n  #\n  # @param key [String] the key pointing to the relevant `DataAssociation`\n  # @param column [Fixnum] an alternative column index to start with\n  # @return [Array\u003cArray\u003cFixnum\u003e\u003e]\n  def next_empty_group(key:, column: nil)\n    nxt_grp = nil\n    loop do\n      present = false\n      nxt_grp = @plate_layout_generator.next_group(column: column)\n      nxt_grp.each do |nxt|\n        prt = @collection.part(nxt[0], nxt[1])\n        present = true if prt.associations[key].present?\n      end\n      break unless present\n    end\n    nxt_grp\n  end\n\n  private\n\n  def associate(index:, key:, data:)\n    part = @collection.part(index[0], index[1])\n    part.associate(key, data)\n  end\nend\n"}},{"library":{"name":"PlateLayoutGenerator","category":"Microtiter Plates","code_source":"# frozen_string_literal: true\n\n# Factory class for instantiating `PlateLayoutGenerator`\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass PlateLayoutGeneratorFactory\n  # Instantiates `PlateLayoutGenerator`\n  #\n  # @param group_size [FixNum] the size of groups of wells, e.g., correspinding\n  #   to replicates\n  # @return [PlateLayoutGenerator]\n  def self.build(group_size: 1, method: nil)\n    PlateLayoutGenerator.new(group_size: group_size, method: method)\n  end\nend\n\n# Provides individual indices or batches of indices from a microtiter plate, in\n#   order from top left ,and yielding each index only once\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass PlateLayoutGenerator\n  def initialize(group_size: 1, method: nil)\n    @group_size = group_size\n    method ||= :cdc_sample_layout\n    @layout = send(method)\n  end\n\n  def next(column: nil)\n    i = column ? first_index_in(column) : 0\n    @layout.slice!(i)\n  end\n\n  def next_group(column: nil)\n    i = column ? first_index_in(column) : 0\n    @layout.slice!(i, @group_size)\n  end\n\n  private\n\n  def first_index_in(column)\n    @layout.index { |x| x[1] == column }\n  end\n\n  def cdc_sample_layout\n    lyt = []\n    [0, 4].each do |j|\n      cols = Array.new(12) { |c| c }\n      cols.each { |c| @group_size.times { |i| lyt \u003c\u003c [i + j, c] } }\n    end\n    lyt\n  end\n\n  # @todo make this responsive to @group_size\n  def cdc_primer_layout\n    lyt = []\n    3.times { |i| [0, 4].each { |j| 12.times { |k| lyt \u003c\u003c [i + j, k] } } }\n    lyt\n  end\nend\n"}}]}